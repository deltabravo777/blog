RSA Decoder
C# Code

Visual Studio 2019, .NET 5.0

This program allows you to encrypt and decrypt messages with RSA keys. You can also make new keys to suit your purposes

You will need four text files on your desktop: SourceFile.txt, SourceKeys.txt, OutputKeys.txt, and OutputFile.txt

When encrypting something in RSA, only the public key in needed. When generating keys with this program, the first half is the public key which you can give to anyone, even publicly for everyone to see. The private key however is needed to decrypt a message that was encrypted with your public key. If you run this program with the SourceKeys.txt file only having the public key to encrypt something, it will run to completion, though decrypting messages does need the private key. Will finesse the mechanics of the program sometime soon

The OutputKeys.txt file gets cleared if you don’t make new keys, so be sure to save your keys every time immediately after you generate new ones. If there is an overflow exception, it is most likely because you’re attempting to encrypt text that is already encrypted, or you’re trying to encrypt a line that is too large for the bit size you used (so make the key sizes bigger or the length of the sentences smaller), and so far this program does not handle double encryption yet. When you enter the keys in the SourceKeys.txt file, you do not need empty spaces as it will work without them, they are there for ease of use

Encryption key size will be asked of when you want to generate keys. There is a minimum of around 1024 bits and a maximum of 4096 bits. Higher bit sized keys take longer to generate though can encode longer messages per line of text (while it can of course take many lines of individual text, and high bit sizes are also mathematically more secure and complex)

27 July 2021: Edits done. The program will make keys with headers labeling the public and private keys explicitly. You also don’t need the OutputKeys.txt file or the OutputFile.txt file since though are generated by the program upon completion

28 July 2021: FileMode parameters changed from Create to OpenOrCreate, so that if a file is not changed it is not cleared

———————————————————————————————————————--

using System;

using System.IO;

using System.Security.Cryptography;

using System.Text;

namespace RSA_Decoder

{

    class Program

    {

        static string _privateKey = "";

        static string _publicKey = "";

        private static UnicodeEncoding _encoder = new UnicodeEncoding();

        static void Main(string[] args)

        {

            Console.WriteLine("Hello World! Let's encrypt some messages! :D");

            Console.WriteLine("Have these .txt files on your desktop: SourceFile.txt, and SourceKeys.txt");

            string sourceFile = Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + @"/SourceFile.txt";

            string sourceKeys = Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + @"/SourceKeys.txt";

            string outputKeyInfo = Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + @"/OutputKeys.txt";

            string outputFileInfo = Environment.GetFolderPath(Environment.SpecialFolder.Desktop) + @"/OutputFile.txt";

            StreamReader textreader = new StreamReader(new FileStream(sourceFile, FileMode.Open, FileAccess.Read, FileShare.None));

            StreamReader keyReader = new StreamReader(new FileStream(sourceKeys, FileMode.Open, FileAccess.Read, FileShare.None));

            StreamWriter keyWriter = new StreamWriter(new FileStream(outputKeyInfo, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None));

            StreamWriter textWriter = new StreamWriter(new FileStream(outputFileInfo, FileMode.OpenOrCreate, FileAccess.Write, FileShare.None));

            Console.WriteLine($"Do you have keys in the file? Y / N");

            ConsoleKey response = Console.ReadKey().Key;

            if (response == ConsoleKey.Y)

            {

                Console.WriteLine($"Got a yes");

                int count = 0;

                while (!keyReader.EndOfStream)

                {

                    string s = keyReader.ReadLine();

                    if (s.Length < 20)

                    {

                        continue;

                    }

                    else if (count == 0)

                    {

                        _publicKey = s;

                        count++;

                    }

                    else

                    {

                        _privateKey = s;

                    }

                }

                Console.WriteLine($"Do you want to encode with your keys or decode with your keys? E or D");

                ConsoleKey response2 = Console.ReadKey().Key;

                if (response2 == ConsoleKey.E)

                {

                    while (textreader.Peek() >= 0)

                    {

                        string s = (textreader.ReadLine());

                        string s2 = Encrypt(s);

                        textWriter.WriteLine(s2);

                    }

                    textWriter.Flush();

                    textWriter.Close();

                    Console.WriteLine();

                    Console.WriteLine("Your encrypted message has been made and exported to the file");

                }

                else if (response2 == ConsoleKey.D)

                {

                    while (textreader.Peek() >= 0)

                    {

                        string s = (textreader.ReadLine());

                        string s2 = Decrypt(s);

                        textWriter.WriteLine(s2);

                    }

                    textWriter.Flush();

                    textWriter.Close();

                    Console.WriteLine();

                    Console.WriteLine("Your decrypted message has been made and exported to the file");

                }

                else

                {

                    Console.WriteLine("Didn't get an E or a D");

                }

            }

            else if (response == ConsoleKey.N)

            {

                Console.WriteLine("Tell me how many bits you want to make the RSA keys in, 1024, 2048, etc, then press enter");

                string bitSize = Console.ReadLine().ToString();

                int bitSizeInts = Int32.Parse(bitSize);

                var rsa = new RSACryptoServiceProvider(bitSizeInts);

                _privateKey = rsa.ToXmlString(true);

                _publicKey = rsa.ToXmlString(false);

                Console.WriteLine($"the private key made is: {_privateKey}");

                Console.WriteLine($"the public key made is: {_publicKey}");

                {

                    keyWriter.WriteLine();

                    keyWriter.WriteLine("The public key is:");

                    keyWriter.WriteLine(_publicKey);

                    keyWriter.WriteLine();

                    keyWriter.WriteLine("The private key is:");

                    keyWriter.WriteLine(_privateKey);

                    keyWriter.Flush();

                    keyWriter.Close();

                }

                Console.WriteLine();

                Console.WriteLine("Your new keys have been generated and are in the file");

                Console.WriteLine("Be sure to copy your new keys to your SourceKeys.txt file");

            }

            else

            {

                Console.WriteLine($"Didn't get a Yes or No");

            }

        }

        public static string Decrypt(string data)

        {

            var rsa = new RSACryptoServiceProvider();

            var dataArray = data.Split(new char[] { ',' });

            byte[] dataByte = new byte[dataArray.Length];

            for (int i = 0; i < dataArray.Length; i++)

            {

                dataByte[i] = Convert.ToByte(dataArray[i]);

            }

            rsa.FromXmlString(_privateKey);

            var decryptedByte = rsa.Decrypt(dataByte, false);

            return _encoder.GetString(decryptedByte);

        }

        public static string Encrypt(string data)

        {

            var rsa = new RSACryptoServiceProvider();

            rsa.FromXmlString(_publicKey);

            var dataToEncrypt = _encoder.GetBytes(data);

            var encryptedByteArray = rsa.Encrypt(dataToEncrypt, false);

            var length = encryptedByteArray.Length;

            var item = 0;

            var sb = new StringBuilder();

            foreach (var x in encryptedByteArray)

            {

                item++;

                sb.Append(x);

                if (item < length)

                    sb.Append(",");

            }

            return sb.ToString();

        }

    }

}
